
<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>メモリモデル | hidetatz.io</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="author" content="Hidetatz Yaginuma">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">

  <style>
    body {
      box-sizing: border-box;
      min-width: 200px;
      max-width: 980px;
      margin: 0 auto;
      padding: 45px;
    }
  </style>

  <link href="/markdown.css" rel="stylesheet"></link>
  <link href="/syntax.css" rel="stylesheet"></link>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>


<body class="markdown-body">
<p><a href="/">&lt;- home</a></p>

<h1 id="メモリモデル">メモリモデル</h1>

<h4 id="2022-01-03">2022/01/03</h4>

<h2 id="概要">概要</h2>

<p>マルチスレッドプログラミングにおいては、プログラムが動作する順番がプログラマの直感に反することがある。以下の例を見てみよう。スレッド1と2はそれぞれ同時に実行される。またここでは、すべての変数は初期値をゼロとする。</p>

<pre><code># スレッド1
x = 1
y = 1

# スレッド2
r1 = y
r2 = x
</code></pre>

<p>スレッド1と2は同時に実行されるが、xとyへのストアはスレッド1からのみ発生するので、データの競合は発生しない。この時、スレッド1と2の実行順序としては次のように考えられる。</p>

<ol>
<li><p>スレッド1 -&gt;  スレッド2と実行されたケース</p>

<pre><code>x = 1
y = 1
	r1 = y // r1は1
	r2 = x // r2は1
</code></pre></li>

<li><p>スレッド2 -&gt;  スレッド1と実行されたケース</p>

<pre><code>	r1 = y // r1は0
	r2 = x // r2は0
x = 1
y = 1
</code></pre></li>

<li><p>1と2がインターリーブされたケース。4通りある。</p></li>
</ol>

<pre><code># インターリーブ1
x = 1
		r1 = y // r1は0
y = 1
		r2 = x // r2は1
</code></pre>

<pre><code># インターリーブ2
x = 1
		r1 = y // r1は0
		r2 = x // r2は1
y = 1
</code></pre>

<pre><code># インターリーブ3
		r1 = y // r1は0
x = 1
		r2 = x // r2は1
y = 1
</code></pre>

<pre><code># インターリーブ4
		r1 = y // r1は0
x = 1
y = 1
		r2 = x // r2は1
</code></pre>

<p>r1とr2の組み合わせは、1のケースで{1, 1}、2のケースで{0, 0}、3のケースは複数のパターンがあるがいずれも{1, 0}となることがわかる。では、r1とr2が{0, 1}となるケースはあるだろうか？実は場合によっては、{0, 1}になることがある。</p>

<p>そもそも上のいずれもケースも、スレッド1・2は、それぞれが自身の命令実行順を変えない (プログラムで指定された通りに命令を実行する) ことを前提としていた。実はこの前提は必ずしも正しくない。なぜならこの前提は、コンパイラとプロセッサによる最適化を考慮していないためである。コンパイラとプロセッサは、最適化のために命令の順序を変えることがある。これではプログラマが困ってしまうので、「メモリ上に保存されたデータの可視性と一貫性について定められたルール」が設けられる。このルールのことを「メモリ一貫性モデル」あるいは単に「メモリモデル」などと呼ぶ。</p>

<p>すなわちメモリモデルには、コンパイラを話題とする「ソフトウェア・メモリモデル」と、プロセッサを話題とする「ハードウェア・メモリモデル」の2種類が存在する。筆者は個人的に、メモリモデルという言葉がこれらをあまり区別せず使われていることが、メモリモデルのわかりにくさの理由の一つではないかと考えている。</p>

<p>この記事では、メモリモデルを理解するために必要な一貫性に関する知識をまず解説し、その後ハードウェア・ソフトウェアに分けてメモリモデルについて書いていく。また最後に、Goにおけるメモリモデルがどのように定義されているのかを概観していく。</p>

<h2 id="逐次一貫性">逐次一貫性</h2>

<p>まずはハードウェア・ソフトウェア関係なく、メモリモデルを理解するために必須な知識である「逐次一貫性」について。
逐次一貫性 (<a href="https://jepsen.io/consistency/models/sequential" target="_blank">Sequential Consistency</a>) とは並行システムにおける一貫性モデルのひとつである。これ自体は単なる一貫性モデルのひとつなので、メモリモデル・マルチスレッドプログラミングとは独立して理解可能である。</p>

<p>逐次一貫性は、1979年のLeslie Lamportの論文「<a href="https://www.microsoft.com/en-us/research/publication/make-multiprocessor-computer-correctly-executes-multiprocess-programs/" target="_blank">How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs</a>」でその定義が与えられている。</p>

<blockquote>
<p>… the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.</p>
</blockquote>

<h2 id="ハードウェア-メモリモデル">ハードウェア・メモリモデル</h2>

<h2 id="ソフトウェア-メモリモデル">ソフトウェア・メモリモデル</h2>

<h2 id="メモリモデル-in-go">メモリモデル in Go</h2>

<p>[^1]:</p>

<p><a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-via="hidetatz" data-show-count="false">Tweet</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>


<script src="/syntax.js"></script>
<script>hljs.highlightAll();</script>
</body>

</html>
