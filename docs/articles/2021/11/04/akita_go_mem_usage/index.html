
<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Taming Go’s Memory Usage, or How We Avoided Rewriting Our Client in Rust — Akita Software | hidetatz.io</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="author" content="Hidetatz Yaginuma">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">

  <style>
    body {
      box-sizing: border-box;
      min-width: 200px;
      max-width: 980px;
      margin: 0 auto;
      padding: 45px;
    }
  </style>

  <link href="/markdown.css" rel="stylesheet"></link>
  <link href="/syntax.css" rel="stylesheet"></link>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>


<body class="markdown-body">
<p><a href="/">&lt;- home</a></p>

<h1>
  <a name="taming-go-s-memory-usage-or-how-we-avoided-rewriting-our-client-in-rust-akita-software" class="anchor" href="#taming-go-s-memory-usage-or-how-we-avoided-rewriting-our-client-in-rust-akita-software" rel="nofollow" aria-hidden="true">
    <span class="octicon octicon-link">
    </span>
  </a>Taming Go’s Memory Usage, or How We Avoided Rewriting Our Client in Rust — Akita Software</h1>

<h4>
  <a name="2021-11-04" class="anchor" href="#2021-11-04" rel="nofollow" aria-hidden="true">
    <span class="octicon octicon-link">
    </span>
  </a>2021/11/04</h4>

<h3>
  <a name="" class="anchor" href="#" rel="nofollow" aria-hidden="true">
    <span class="octicon octicon-link">
    </span>
  </a><a href="https://www.akitasoftware.com/blog-posts/taming-gos-memory-usage-or-how-we-avoided-rewriting-our-client-in-rust">https://www.akitasoftware.com/blog-posts/taming-gos-memory-usage-or-how-we-avoided-rewriting-our-client-in-rust</a></h3>

<ul>
<li>The lessons learned are interesting:

<ul>
<li><strong>Reduce fixed overhead</strong>. Go’s garbage collection ensures that you pay for each live byte with another byte of system memory. Keeping fixed overhead low will reduce resident set size.</li>
<li><strong>Profile allocation, not just live data</strong>. This reveals what is making the Go garbage collector perform work, and spikes in memory usage are usually due to increased activity at those sites.</li>
<li><strong>Stream, don’t buffer</strong>. It’s a common mistake to collect the output of one phase of processing before going on to the next. But this can lead to an allocation that is duplicative of the memory allocations you must already make for the finished result, and maybe cannot be freed until the entire pipeline is done.</li>
<li><strong>Replace frequent, small allocations</strong> by a longer-lived one covering the entire workflow. The result is not very idiomatically Go-like, but can have a huge impact.</li>
<li>Avoid generic libraries that come with <strong>unpredictable memory costs</strong>. Go’s reflection capabilities are great and let you build powerful tools. But, using them often results in costs that are not easy to pin down or control. Idioms as simple as passing in a slice rather than a fixed-sized array can have performance and memory costs. Fortunately, Go code is very easy to generate using the standard library’s go/ast and go/format packages.</li>
</ul></li>
<li>After all, my impression: We must profile, know bottleneck, read code, apply a fix, run benchmark, and loop. That is it.</li>
</ul>

<p><a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-via="hidetatz" data-show-count="false">Tweet</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<hr />

<div style="text-align: center;">
  <a href="/">home</a>
</div>


<hr>

<footer>
<p style="text-align:center">© 2017-2021 Hidetatz Yaginuma</p>
</footer>
<script src="/syntax.js"></script>
<script>hljs.highlightAll();</script>
</body>

</html>
