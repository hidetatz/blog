
<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>How Discord Stores Billions of Messages | by Stanislav Vishnevskiy | Discord Blog | dtyler.io</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="author" content="Hidetatsu Yaginuma">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">

  <style>
    body {
      box-sizing: border-box;
      min-width: 200px;
      max-width: 980px;
      margin: 0 auto;
      padding: 45px;
    }
  </style>

  <link href="/markdown.css" rel="stylesheet"></link>
  <link href="/syntax.css" rel="stylesheet"></link>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>


<body class="markdown-body">
<p><a href="/">&lt;- home</a></p>

<h1>
  <a name="how-discord-stores-billions-of-messages-by-stanislav-vishnevskiy-discord-blog" class="anchor" href="#how-discord-stores-billions-of-messages-by-stanislav-vishnevskiy-discord-blog" rel="nofollow" aria-hidden="true">
    <span class="octicon octicon-link">
    </span>
  </a>How Discord Stores Billions of Messages | by Stanislav Vishnevskiy | Discord Blog</h1>

<h4>
  <a name="2021-11-03" class="anchor" href="#2021-11-03" rel="nofollow" aria-hidden="true">
    <span class="octicon octicon-link">
    </span>
  </a>2021/11/03</h4>

<h3>
  <a name="" class="anchor" href="#" rel="nofollow" aria-hidden="true">
    <span class="octicon octicon-link">
    </span>
  </a><a href="https://blog.discord.com/how-discord-stores-billions-of-messages-7fa6ec7ee4c7">https://blog.discord.com/how-discord-stores-billions-of-messages-7fa6ec7ee4c7</a></h3>

<ul>
<li>Originally Discord used mongoDB for the primary datastore, but as expected, many issues appered at its scale.</li>
<li>They wanted to migrate to new database</li>
<li>read/write patterns:

<ul>
<li>reads were extremely random</li>
<li>read/write ratio was about <sup>50</sup>&frasl;<sub>50</sub></li>
<li>Voice chat heavy Discord servers send almost no messages. This means they send a message or two every few days. In a year, this kind of server is unlikely to reach 1,000 messages.</li>
<li>Private text chat heavy Discord servers send a decent number of messages, easily reaching between 100 thousand to 1 million messages a year. The data they are requesting is usually very recent only.</li>
<li>Large public Discord servers send a lot of messages. They have thousands of members sending thousands of messages a day and easily rack up millions of messages a year. They almost always are requesting messages sent in the last hour and they are requesting them often.</li>
</ul></li>
<li>Requirements definitions:

<ul>
<li>Linear scalability</li>
<li>Automatic failover</li>
<li>Low maintenance</li>
<li>Proven to work

<ul>
<li>not too new technology</li>
</ul></li>
<li>Predictable performance

<ul>
<li>Do not want to cache messages in Redis</li>
</ul></li>
<li>Not a blob store</li>
<li>Open source</li>
</ul></li>
<li>Cassandra was the only option which meets all the requirements</li>
<li>Cassandra is KKV store; First K identifies node and location on the disk. The second is the clustering key which identifiesa row in a partition

<ul>
<li>A partition is something like ordered dictionary</li>
</ul></li>
<li>While migration, double write to MongoDB and Cassandra is made</li>
<li>Cassandra is AP database; it is anti-pattern to read-before-write in Cassandra. What Cassandra does is essentially an upsert. You can write to any node and it will resolve conflicts automatcally using &ldquo;last write wins&rdquo; semantics.

<ul>
<li>So, in case a user edits a message at the same time as another user deletes the same message, because Cassandra&rsquo;s write is upsert, the row becomes empty except the primary key and text.</li>
<li>Possible solution was: 1. write the whole message back when editing the message. 2. Delete a row if a message corruption is figured out.</li>
<li>Discord chose the second option; delete messages which lacks a required column.</li>
</ul></li>
<li>Six months after Cassandra production service in, it because unresponsive

<ul>
<li>They noticed 10 sec GC constantly is happening.</li>
<li>The Puzzles and Dragons Subreddit public Discord serverwas the culprit. Apparently, they deleted millions of messages and only one message was left.</li>
<li>Because Cassandra does delete as soft-delete (called Tombstone), When a user loaded this channel, even though there was only 1 message, Cassandra had to effectively scan millions of message tombstones. As a result, it generates garbage faster than the JVM collect it.</li>
<li>They did 2 things; changed the tombstone lifespan from 10 days to 2 days. changed the query code to track empty buckets and avoid them in the future for a channel.</li>
</ul></li>
</ul>

<p><a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-via="dty1er1" data-show-count="false">Tweet</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<hr />

<div style="text-align: center;">
  <a href="/">home</a>
</div>


<hr>

<footer>
<p style="text-align:center">Â© 2017-2021 Hidetatsu Yaginuma</p>
</footer>
<script src="/syntax.js"></script>
<script>hljs.highlightAll();</script>
</body>

</html>
